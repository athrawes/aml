Effect = use "System/Control/Effect"
Pair = use "System/Collections/Pair"

module List :> Effect =
  type List<T> =
    | Empty of _
    | NonEmpty of Pair<T,List<T>>

  # @inheritdoc
  from: T -> List.NonEmpty<T>
    = value -> Pair.from value _

  # @inheritdoc
  # @override
  map = list -> callback ->
    match list
    | Empty -> list
    | NonEmpty pair -> {
        head = callback (Pair.fst pair),
        tail = map (Pair.snd pair) callback
      }

  # @inheritdoc
  then = list -> callback ->
    flatten (map list callback)

  # An alias for `List.then`, which may be more intuitive in many contexts.
  # Since the callback parameter maps each element in the origin list to an
  # entire list of its own, `list.flatMap` takes the origin list,
  # applies the callback parameter to each argument, and then flattens the
  # resulting list of lists into a single list.
  #
  # @include then
  flatMap = then

  # Flattens one level of a multi-dimensional list.
  flatten
    : List<List<T>> -> List<T>
    = lists ->
      match lists
      | Empty -> List.Empty
      | NonEmpty pair -> concat (Pair.fst pair) (flatten (Pair.snd pair))

  # Appends two lists together. The lists are concatenated left to right, so the
  # elements from the first list provided come first in the list, and the
  # elements from the second list provided come later.
  concat
    : List<T> -> List<T> -> List<T>
    = first -> second ->
      match first
      | Empty -> second
      | NonEmpty pair -> {
          head = (Pair.fst pair),
          tail = concat (Pair.snd pair) second
        }

  (++) = concat
