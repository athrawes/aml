Effect = use "System/Control/Effect"
{ _ as Maybe, Some, None } = use "System/Effects/Maybe"

module List :> Effect =
  type List<T> =
    | Empty of {
        head: None,
        tail: None,
      }
    | NonEmpty of {
        head: Some<T>,
        tail: Maybe<List<T>>,
      }

  empty: List<_>.Empty = {
    head = None,
    tail = None,
  }

  # @inheritdoc
  from: T -> List.NonEmpty<T>
    = value -> {
      head = Some value,
      tail = None,
    }

  # @inheritdoc
  # @override
  map = list -> callback ->
    match list
    | Empty -> list
    | NonEmpty { head, tail } -> {
        head = Some(callback head.value),
        tail = match tail
               | Some { value } -> map value callback
               | None -> None
      }

  # @inheritdoc
  then = list -> callback ->
    flatten (map list callback)

  # An alias for `List.then`, which may be more intuitive in many contexts.
  # Since the callback paramter maps each element in the origin list to an
  # entire list of its own, `list.flatMap` takes the origin list,
  # applies the callback parameter to each argument, and then flattens the
  # resulting list of lists into a single list.
  #
  # @include then
  flatMap = then

  flatten: List<List<T>> -> List<T>
    = lists ->
      match lists
      | Empty -> lists
      | NonEmpty { head, tail } ->
          match tail
          | Some { value } -> append head (flatten value)
          | None -> head

  append: List<T> -> List<T> -> List<T>
    = first -> second ->
      match first
      | Empty -> second
      | NonEmpty { head, tail } ->
          match tail
          | Some { value } -> {
              head = head,
              tail = Some(append value second)
            }
          | None -> { head, tail = Some second }
