{ Pair, fst, snd } â‰” use "Collections/Pair"
Sequence â‰” use "Collections/Sequences/Sequence"
{ None } â‰” use "Effects/Maybe"

module List extends Sequence

type List<'t> extends Sequence<'t> =
  | NonEmpty of Pair<'t, List<'t>>
  | Empty of None

# Determines whether two lists are equal. Two lists are equal if they have the
# same elements in the same order.
#
# Time complexity: O(n)
#   - n is the length of the first list
# Space complexity: O(mn)
#   - m is the length of the first list
#   - n is the length of the second list
#
# ```aml
# [1, 2, 3] = [1, 2, 3]
# # => true
#
# [1, 2, 3] = [1, 2, 4]
# # => false
# ```
(=) : Setoid 't â‡’ List<'t> â†’ List<'t> â†’ ð”¹
(=) â‰” a â†’ b â†’
  match a, b
  | Empty, Empty â‡’ true
  | NonEmpty (p1), NonEmpty (p2) â‡’ p1 = p2
  | _ â‡’ false

# Returns a new list which has the given item appended to the end of it.
#
# Time complexity: O(n)
#   - n is the length of the list
# Space complexity: O(n)
#   - n is the length of the list
#
# ```aml
# append [1, 2, 3] 4
# # â‡’ [1, 2, 3, 4]
# ```
append â‰” list â†’ item â†’
  match list
  | Empty â‡’ from item
  | NonEmpty (pair) â‡’ Pair.from
    (fst pair)
    (append (snd pair) item)

# Returns a new list which is the result of appending two lists together. The
# lists are concatenated left to right, so the elements from the first list
# provided come first in the list, and the elements from the second list
# provided come later.
#
# Time complexity: O(n)
#   - n is the length of the first list
# Space complexity: O(mn)
#   - m is the length of the first list
#   - n is the length of the second list
#
# ```aml
# concat [1, 2, 3] [4, 5, 6]
# # => [1, 2, 3, 4, 5, 6]
# ```
concat â‰” first â†’ second â†’
  match first
  | Empty â‡’ second
  | NonEmpty (pair) â‡’ Pair.from
    (fst pair)
    (concat (snd pair) second)

# Returns a new list with the given item as the first and only element.
#
# Time complexity: O(1)
# Space complexity: O(1)
#
# ```aml
# from 1
# # => [1]
# ```
from â‰” value â†’ Pair.from value Empty

# Returns the first element of a list, if it exists.
#
# Time complexity: O(1)
# Space complexity: O(1)
#
# ```aml
# head [1, 2, 3]
# # => Some 1
#
# head []
# # => None
# ```
head : List<'t> â†’ Maybe<'t>
head â‰” list â†’
  match list
  | Empty â‡’ None
  | NonEmpty (pair) â‡’ Some (fst pair)

# Creates a new list from a given list and a callback to transform each element
# in the list.
#
# Time complexity: O(n)
#   - n is the length of the list
# Space complexity: O(n)
#   - n is the length of the list
#
# ```aml
# map [1, 2, 3] (x â†’ x + 1)
# # => [2, 3, 4]
# ```
map â‰” list â†’ callback â†’
  match list
  | Empty â‡’ list
  | NonEmpty (pair) â‡’ Pair.from
    (callback (fst pair))
    (map (snd pair) callback)

# Returns a new list which has all elements of the input list except for the
# first element. If the input list is empty or has only one element, an empty
# list is returned.
#
# Time complexity: O(1)
# Space complexity: O(1)
#
# ```aml
# tail [1, 2, 3]
# # => [2, 3]
#
# tail [1]
# # => []
#
# tail []
# # => []
# ```
tail : List<'t> â†’ List<'t>
tail â‰” list â†’
  match list
  | Empty â‡’ list
  | NonEmpty (pair) â‡’ snd pair

# Returns a new list with a given item prepended to it.
#
# Time complexity: O(1)
# Space complexity: O(1)
#
# ```aml
# prepend [2, 3] 1
# # => [1, 2, 3]
# ```
prepend â‰” list â†’ item â†’ Pair.from item list

# An infix alias for `prepend`, but with the arguments flipped. This allows you
# to use the `::` operator to prepend an item to a list.
#
# Time complexity: O(1)
# Space complexity: O(1)
#
# ```aml
# 1 :: [2, 3]
# # => [1, 2, 3]
# ```
(::) â‰” flip prepend

# Returns a new list which is in the reverse order of the input list.
#
# Time complexity: O(n)
#   - n is the length of the list
# Space complexity: O(n)
#   - n is the length of the list
#
# ```aml
# reverse [1, 2, 3]
# # => [3, 2, 1]
# ```
reverse : List<'t> â†’ List<'t>
reverse â‰” list â†’
  match list
  | Empty â‡’ list
  | NonEmpty (pair) â‡’ concat
    (reverse (snd pair))
    (from (fst pair))
