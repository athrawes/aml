{ ğ”¹, true, false, or, Â¬ } â‰” use "Prelude/Boolean"

module Sequence extends Monoid Monad Traversable
  type Sequence<'a>

# Returns true if all elements in the sequence satisfy the given predicate
# function. Returns false otherwise.
#
# Time complexity: O(n)
#   - where n is the number of elements in the sequence
# Space complexity: O(1)
#
# ```aml
# all [1, 2, 3] (x â†’ x < 4)
# # => true
#
# all [1, 2, 3] (x â†’ x < 3)
# # => false
# ```
all : Sequence 'm â‡’ 'm<'t> â†’ ('t â†’ ğ”¹) â†’ ğ”¹
all â‰” seq â†’ predicate â†’ Â¬ (seq âˆƒ (Â¬ âˆ˜ predicate)))

# An infix alias for `all`.
#
# ```aml
# [1, 2, 3] âˆ€ (x â†’ x < 4)
# # => true
#
# [1, 2, 3] âˆ€ (x â†’ x < 3)
# # => false
# ```
# @include all
(âˆ€) â‰” all

# Returns true if any element in the sequence satisfies the given predicate
# function. Returns false otherwise.
#
# Time complexity: O(n)
#   - where n is the number of elements in the sequence
# Space complexity: O(1)
#
# ```aml
# any [1, 2, 3] (x â†’ x = 2)
# # => true
#
# any [1, 2, 3] (x â†’ x = 4)
# # => false
# ```
any : Sequence 'm â‡’ 'm<'t> â†’ ('t â†’ ğ”¹) â†’ ğ”¹
any â‰” seq â†’ predicate â†’
  reduce seq (or âˆ˜ predicate) false

# An infix alias for `any`.
#
# ```aml
# [1, 2, 3] âˆƒ (x â†’ x = 2)
# # => true
#
# [1, 2, 3] âˆƒ (x â†’ x = 4)
# # => false
# ```
# @include any
(âˆƒ) â‰” any

# Returns true if none of the elements in the sequence satisfy the given
# predicate function. Returns false otherwise.
#
# Time complexity: O(n)
#   - where n is the number of elements in the sequence
# Space complexity: O(1)
#
# ```aml
# [1, 2, 3] âˆ„ (x â†’ x = 2)
# # => false
#
# [1, 2, 3] âˆ„ (x â†’ x = 4)
# # => true
# ```
(âˆ„) â‰” Â¬ âˆ˜âˆ˜âˆ˜ âˆƒ

chain â‰” seq â†’ callback â†’ seq <$> callback | flatten

# Determines if the given element is in the sequence. The elements of the
# sequence must be comparable using the `==` operator.
#
# Time complexity: O(n)
#   - where n is the number of elements in the sequence
# Space complexity: O(1)
#
# ```aml
# contains? [1, 2, 3] 2
# # => true
#
# contains? [1, 2, 3] 4
# # => false
# ```
contains? : Sequence 'm, Setoid 't â‡’ 'm<'t> â†’ 't â†’ ğ”¹
contains? â‰” seq â†’ element â†’ seq âˆƒ (x â†’ x = element)

# An infix alias for `contains?`.
#
# ```aml
# [1, 2, 3] âˆ‹ 2
# # => true
#
# [1, 2, 3] âˆ‹ 4
# # => false
# ```
# @include contains?
(âˆ‹) â‰” contains?

# Determines if the given element is not in the sequence. The elements of the
# sequence must be comparable using the `==` operator.
#
# Time complexity: O(n)
#   - where n is the number of elements in the sequence
# Space complexity: O(1)
#
# ```aml
# 2 âˆŒ [1, 2, 3]
# # => false
#
# 4 âˆŒ [1, 2, 3]
# # => true
# ```
(âˆŒ) â‰” not âˆ˜âˆ˜âˆ˜ (âˆ‹)

# Returns a new sequence which contains all the elements of the first sequence
# which are not in the second sequence.
#
# Time complexity: O(mn)
#   - where m is the number of elements in the first sequence
#   - where n is the number of elements in the second sequence
# Space complexity: O(m)
#   - where m is the number of elements in the first sequence
#
# ```aml
# difference [1, 2, 3] [2, 3, 4]
# # => [1]
# ```
difference : Sequence 'm â‡’ 'm<'t> â†’ 'm<'t> â†’ 'm<'t>
difference â‰” a â†’ b â†’ filter a (x â†’ x âˆ‰ b)

# An infix alias for `difference`.
#
# ```aml
# [1, 2, 3] âˆ– [2, 3, 4]
# # => [1]
# ```
# @include difference
(âˆ–) â‰” difference

# Drops the first `count` elements from the sequence and returns a new sequence
# with the remaining elements. If `count` is greater than the number of elements
# in the sequence, an empty sequence is returned.
#
# Time complexity: O(n)
#   - where n is the max of `count` and the number of elements in the sequence
# Space complexity: O(n)
#   - where n is the max of `count` and the number of elements in the sequence
#
# ```aml
# drop 2 [1, 2, 3]
# # => [3]
# ```
drop : Sequence 'm â‡’ â„• â†’ 'm<'t> â†’ 'm<'t>
drop â‰” count â†’ seq â†’
  if count < 1
  then seq
  else drop (count - 1) (tail seq)

# Drops elements from the sequence until the predicate function returns false.
# Returns a new sequence with the remaining elements. If the predicate function
# always returns true, an empty sequence is returned.
#
# Time complexity: O(n)
#   - where n is the number of elements in the sequence
# Space complexity: O(n)
#   - where n is the number of elements in the sequence
#
# ```aml
# drop-while [1, 2, 3, 1, 2, 3] (x â†’ x < 3)
# # => [3, 1, 2, 3]
# ```
drop-while : Sequence 'm â‡’ 'm<'t> â†’ ('t â†’ ğ”¹) â†’ 'm<'t>
drop-while â‰” seq â†’ predicate â†’
  match head seq
  | None â‡’ seq
  | Some x =>
    if predicate x
    then drop-while (tail seq) predicate
    else seq

# Attempts to return the element at the given index in the sequence. If the
# index is out of bounds, `None` is returned.
#
# Time complexity: O(n)
#   - where n is the number of elements in the sequence
# Space complexity: O(1)
#
# ```aml
# element-at [1, 2, 3] 0
# # => Some 1
#
# element-at [1, 2, 3] 1
# # => Some 2
#
# element-at [1, 2, 3] 2
# # => Some 3
#
# element-at [1, 2, 3] 3
# # => None
# ```
element-at : Sequence 'm â‡’ 'm<'t> â†’ â„¤ â†’ Maybe<'t>
element-at â‰” seq â†’ index â†’
  if index < 0
  then None
  else match head seq
    | None â‡’ None
    | Some x =>
      if index = 0
      then Some x
      else element-at (tail seq) (index - 1)

# Returns a new sequence which contains all the elements of the first sequence
# which match the given predicate function.
#
# Time complexity: O(n)
#   - where n is the number of elements in the sequence
# Space complexity: O(n)
#   - where n is the number of elements in the sequence
#
# ```aml
# filter [1, 2, 3] (x â†’ x < 3)
# # => [1, 2]
# ```
filter : Sequence 'm â‡’ 'm<'t> â†’ ('t â†’ ğ”¹) â†’ 'm<'t>
filter â‰” seq â†’ predicate â†’
  match head seq
  | None â‡’ seq
  | Some x =>
    if predicate x
    then x :: (filter (tail seq) predicate)
    else filter (tail seq) predicate

# Takes a sequence of sequences and returns a new sequence with all of the
# elements in the sub-sequences concatenated together.
#
# Time complexity: O(n)
#   - where n is the total number of elements in all of the sub-sequences
# Space complexity: O(n)
#   - where n is the total number of elements in all of the sub-sequences
#
# ```aml
# flatten [[1, 2], [3, 4]]
# # => [1, 2, 3, 4]
# ```
flatten : Sequence 'm â‡’ 'm<'m<'t>> â†’ 'm<'t>
flatten â‰” seq â†’
  match head seq with
  | Some x â‡’ concat x (flatten (tail seq))
  | None â‡’ seq

# Returns the first element in the sequence, if it exists.
#
# Time complexity: O(1)
# Space complexity: O(1)
#
# ```aml
# head [1, 2, 3]
# # => Some 1
#
# head []
# # => None
# ```
head : Sequence 'm â‡’ 'm<'t> â†’ Maybe<'t>

# Returns true if the given element is in the sequence. Returns false otherwise.
#
# Time complexity: O(n)
#   - where n is the number of elements in the sequence
# Space complexity: O(1)
#
# ```aml
# is-element-of? 2 [1, 2, 3]
# # => true
#
# is-element-of? 4 [1, 2, 3]
# # => false
# ```
is-element-of? : Sequence 'm, Setoid 't â‡’ 't â†’ 'm<'t> â†’ ğ”¹
is-element-of? â‰” element â†’ seq â†’
  seq âˆƒ (x â†’ x = element)

# An infix alias for `is-element-of?`.
#
# ```aml
# 2 âˆˆ [1, 2, 3]
# # => true
#
# 4 âˆˆ [1, 2, 3]
# # => false
# ```
# @include is-element-of?
(âˆˆ) â‰” is-element-of?

# Returns true if the given element is not in the sequence. Returns false
# otherwise.
#
# Time complexity: O(n)
#   - where n is the number of elements in the sequence
# Space complexity: O(1)
#
# ```aml
# 2 âˆ‰ [1, 2, 3]
# # => false
#
# 4 âˆ‰ [1, 2, 3]
# # => true
# ```
(âˆ‰) â‰” not âˆ˜âˆ˜âˆ˜ (âˆˆ)

# Returns true if the first sequence is a subset of the second sequence; in
# other words, if all elements in the first sequence are also in the second
# sequence.
#
# Time complexity: O(mn)
#   - where m is the number of elements in the first sequence
#   - where n is the number of elements in the second sequence
# Space complexity: O(1)
#
# ```aml
# is-subset-of? [1, 2, 3] [1, 2, 3, 4]
# # => true
#
# is-subset-of? [1, 2, 3] [1, 2, 3]
# # => true
#
# is-subset-of? [1, 2, 3] [1, 2]
# # => false
# ```
is-subset-of? : Sequence 'm, Setoid 't â‡’ 'm<'t> â†’ 'm<'t> â†’ ğ”¹
is-subset-of? â‰” a â†’ b â†’
  a âˆ€ (x â†’ x âˆˆ b)

# An infix alias for `is-subset-of?`.
#
# ```aml
# [1, 2, 3] âŠ‚ [1, 2, 3, 4]
# # => true
#
# [1, 2, 3] âŠ‚ [1, 2, 3]
# # => true
#
# [1, 2, 3] âŠ‚ [1, 2]
# # => false
# ```
# @include is-subset-of?
(âŠ‚) â‰” is-subset-of?

# Checks to see if the first sequence is not a subset of the second sequence, or
# in other words, if the first sequence contains at least one element that is
# not in the second sequence.
#
# Time complexity: O(mn)
#   - where m is the number of elements in the first sequence
#   - where n is the number of elements in the second sequence
# Space complexity: O(1)
#
# ```aml
# [1, 2, 3] âŠ„ [1, 2, 3, 4]
# # => false
#
# [1, 2, 3] âŠ„ [1, 2, 3]
# # => false
#
# [1, 2, 3] âŠ„ [1, 2]
# # => true
# ```
(âŠ„) â‰” not âˆ˜âˆ˜âˆ˜ (âŠ‚)

# Returns the length of the sequence.
#
# Time complexity: O(n)
#   - where n is the number of elements in the sequence
# Space complexity: O(1)
#
# ```aml
# length [1, 2, 3]
# # => 3
# ```
length : Sequence 'm â‡’ 'm<'t> â†’ â„•
length â‰” seq â†’ reduce seq ((add 1) âˆ˜âˆ˜âˆ˜ const) 0

# Returns a new sequence with the given element added on the front.
#
# ```aml
# prepend 1 [2, 3]
# # => [1, 2, 3]
# ```
prepend : Sequence 'm â‡’ 't â†’ 'm<'t> â†’ 'm<'t>

# An infix alias for `prepend`.
#
# ```aml
# 1 :: [2, 3]
# # => [1, 2, 3]
# ```
# @include prepend
(::) â‰” prepend

# Reduce a sequence to a single value by applying a function to each element and
# passing an accumulator value between each application.
#
# Time complexity: O(n)
#   - where n is the number of elements in the sequence
# Space complexity: O(1)
#
# ```aml
# reduce [1, 2, 3] (+) 0
# # => 6
# ```
reduce : Sequence 'm â‡’ 'm<'t> â†’ ('a â†’ 't â†’ 'a) â†’ 'a â†’ 'a
reduce â‰” seq â†’ callback â†’ initial â†’
  match head seq
  | Some x â‡’ reduce (tail seq) callback (callback initial x)
  | None â‡’ initial

# Sums the elements of the sequence.
#
# Time complexity: O(n)
#   - where n is the number of elements in the sequence
# Space complexity: O(1)
#
# ```aml
# sum [1, 2, 3]
# # => 6
# ```
# FIXME: Need exact type for `Addable` stand-in here
sum : Sequence 'm, Addable 't, Plus 't â‡’ 'm<'t> â†’ 't
sum â‰” seq â†’ reduce seq ('t.+) 't.zero

# An alias for `sum`.
#
# ```aml
# âˆ‘ [1, 2, 3]
# # => 6
# ```
âˆ‘ â‰” sum

# Returns a new sequence with all elements in the input sequence except the
# first one. If the input sequence is empty, an empty sequence is returned.
#
# ```aml
# tail [1, 2, 3]
# # => [2, 3]
# ```
tail : Sequence 'm â‡’ 'm<'t> â†’ 'm<'t>

# Returns a new sequence which contains all the unique elements of both input
# sequences.
#
# ```aml
# union [1, 2, 3] [2, 3, 4]
# # => [1, 2, 3, 4]
# ```
union : Sequence 'm â‡’ 'm<'t> â†’ 'm<'t> â†’ 'm<'t>
union â‰” a â†’ b â†’ a ++ (b âˆ– a)

# An infix alias for `union`.
#
# ```aml
# [1, 2, 3] âˆª [2, 3, 4]
# # => [1, 2, 3, 4]
# ```
# @include union
(âˆª) â‰” union
