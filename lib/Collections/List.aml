Effect = use "Control/Effect"
{ Pair, :pair } = use "Collections/Pair"

module List :> Effect

type :list<'t> =
  | :non-empty of :pair<'t, :list<'t>>
  | :empty

from : 't -> :list<'t>
from = value -> Pair.from value :list[:empty]

map = list callback ->
  match list
  | :empty => list
  | :non-empty [pair] => Pair.from
      (callback (Pair.fst pair))
      (map (Pair.snd pair) callback)

then = list callback ->
  flatten (map list callback)

# An alias for `List.then`, which may be more intuitive in many contexts. Since
# the callback parameter maps each element in the origin list to an entire list
# of its own, `list.flatMap` takes the origin list, applies the callback
# parameter to each argument, and then flattens the resulting list of lists into
# a single list.
#
# @include then
flatMap = then

# Flattens one level of a multi-dimensional list.
flatten : :list<:list<'t>> -> :list<'t>
flatten = lists ->
  match lists
  | :empty => :list[:empty]
  | :non-empty [pair] => concat (Pair.fst pair) (flatten (Pair.snd pair))

# Returns a new list which is the result of appending two lists together. The
# lists are concatenated left to right, so the elements from the first list
# provided come first in the list, and the elements from the second list
# provided come later.
concat : :list<'t> -> :list<'t> -> :list<'t>
concat = first second ->
  match first
  | :empty => second
  | :non-empty [pair] => Pair.from
      (Pair.fst pair)
      (concat (Pair.snd pair) second)

# An infix alias for `concat`.
#
# @include concat
(++) = concat

# Returns a new list with a given item prepended to it.
prepend : 't -> :list<'t> -> :list<'t>
prepend = item list -> Pair.from item list

# An infix alias for `prepend`.
#
# @include prepend
(::) = prepend

# Returns a new list which is in the reverse order of the input list.

reverse : :list<'t> -> :list<'t>
reverse = list ->
  match list
  | :empty => list
  | :non-empty [pair] => concat
      (reverse(Pair.snd pair))
      (List.from(Pair.fst pair))
