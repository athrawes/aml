type Alt<'a> extends Functor<'a>
trait Alt extends Functor
  alt : Alt 'm â‡’ 'm<'a> â†’ 'm<'a> â†’ 'm<'a>

type Alternative<'a> extends Applicative<'a>, Plus<'a>
trait Alternative extends Applicative Plus

type Applicative<'a> extends Apply<'a>
trait Applicative extends Apply
  from : Applicative 'm â‡’ 'a â†’ 'm<'a>

  replace : Applicative 'm â‡’ 'm<'a> â†’ 'b â†’ 'm<'b>
  replace â‰” ma â†’ b â†’ lift-a1 (const b) ma

  (<$) â‰” replace

  inject : Applicative 'm â‡’ 'a â†’ 'm<'b> â†’ 'm<'a>
  inject â‰” a â†’ mb â†’ lift-a1 (const a) mb

  ($>) â‰” inject

  lift-a0 : Applicative 'm â‡’ 'a â†’ 'm<'a>
  lift-a0 â‰” from

  lift-a1 : Applicative 'm â‡’ ('a â†’ 'b) â†’ 'm<'a> â†’ 'm<'b>
  lift-a1 â‰” callback â†’ ma â†’ (from callback) <*> ma

  lift-a2 : Applicative 'm â‡’ ('a â†’ 'b â†’ 'c) â†’ 'm<'a> â†’ 'm<'b> â†’ 'm<'c>
  lift-a2 â‰” callback â†’ ma â†’ mb â†’ (from callback) <*> ma <*> mb

type Apply<'a> extends Functor<'a>
trait Apply extends Functor
  ap : Apply 'm â‡’ 'm<('a â†’ 'b)> â†’ 'm<'a> â†’ 'm<'b>

  # An alias for `ap`.
  # @include ap
  (<*>) â‰” ap

  (<**>) â‰” flip (<*>)

type Bifunctor<'a, 'b> extends Functor<'b>
trait Bifunctor extends Functor
  bimap : Bifunctor 'm â‡’ 'm<'a, 'c> â†’ ('a â†’ 'b) â†’ ('c â†’ 'd) â†’ 'm<'b, 'd>

type Category<'a> extends Semigroupoid<'a, 'a>
trait Category extends Semigroupoid
  # The identity object for a given category.
  #
  # This object should behave as one would expect for an identity object.
  # As an example, given a category of multiplication, the identity object would
  # be `1`, since `1 * x` is always `x`.
  #
  # This identity should behave the same whether it's on the left or right side
  # of a composition.
  #
  # Given an object `a` which is a member of a category `'m`, the following
  # should hold:
  #
  # - `identity >> a` should be the same as `a`
  # - `a >> identity` should be the same as `a`
  identity : Category 'm â‡’ 'm<_>

type Chain<'a> extends Apply<'a>
trait Chain extends Apply
  # Allows chaining functions which return instances of the current type.
  #
  # ```aml
  # (Maybe.from 42)
  # â–· chain (value â†’ value / 2) # Maybe<Float> (21.0)â†’
  # â–· chain (value â†’ value / 5) # Maybe<Float> (4.2)
  # ```
  chain : Chain 'm â‡’ 'm<'a> â†’ ('a â†’ 'm<'b>) â†’ 'm<'b>

  # An alias for `chain`. Allows chaining functions which return instances of
  # the current type.
  #
  # ```aml
  # (Maybe.from 42)
  # â–· then (value â†’ value / 2) # Maybe<Float> (21.0)
  # â–· then (value â†’ value / 5) # Maybe<Float> (4.2)
  # ```
  then â‰” chain

  # An infix alias for `chain`.
  #
  # @include chain
  #
  # ```aml
  # (Maybe.from 42)
  # >>= (value â†’ value / 2) # Maybe<Float> (21.0)
  # >>= (value â†’ value / 5) # Maybe<Float> (4.2)
  # ```
  (>>=) â‰” chain

  # An infix alias for `chain`, but with the arguments reversed.
  #
  # @include chain
  #
  # ```aml
  # (value â†’ value / 2) =<< (Maybe.from 42) # Maybe<Float> (21)
  # ```
  (=<<) â‰” flip (>>=)

  # Composes two functions by Kleisli composition.
  k-compose : ('a â†’ 'm<'b>) â†’ ('b â†’ 'm<'c>) â†’ ('a â†’ 'm<'c>)
  k-compose â‰” a-to-mb b-to-mc â†’
      a-to-mb >> ((flip chain) b-to-mc)

  # An infix alias for `k-compose`.
  # @include k-compose
  (>=>) â‰” k-compose

  # An infix alias for `k-compose`, but with the arguments reversed.
  # @include k-compose
  (<=<) â‰” flip (>=>)

  flatten : Chain 'm â‡’ 'm<'m<'a>> â†’ 'm<'a>
  flatten â‰” mma â†’
      mma >>= É©

type ChainRec<'a> extends Chain<'a>
trait ChainRec extends Chain
  # the same type as the next function in the sequence. The first function in
  # Chains together a sequence of functions, each of which returns a value of
  # the sequence is passed the `next` and `done` callbacks, which it can use to
  # continue the chain or terminate it, respectively. The `next` callback takes
  # the next function in the sequence as its first argument, and the `done`
  # callback takes the final value of the chain as its first argument.
  #
  # functions that each return a value of the same type as the next function in
  # The `chain-rec` function is useful for chaining together a sequence of
  # the sequence. The `chain-rec` function is similar to the `chain` function,
  # except that it allows the chain to be terminated early by calling the `done`
  # callback.
  #
  # For example, the following code uses `chain-rec` to implement a function
  # that returns the first even number in a sequence, or `None` if no even
  # number is found:
  #
  # ```aml
  # ```
  chain-rec : ChainRec 'm
    â‡’ (('a â†’ 'c) â†’ ('b â†’ 'c) â†’ 'a â†’ 'm<'c>)
    â†’ 'a
    â†’ 'm<'b>

type Contramap<'a>
trait Contramap
  contramap : Contravariant 'm â‡’ 'm<'a> â†’ ('b â†’ 'a) â†’ 'm<'b>

type Comonad<'a> extends Extend<'a>
trait Comonad extends Extend
  extract : Comonad 'm â‡’ 'm<'a> â†’ _ â†’ 'a

type Extend<'a> extends Functor<'a>
trait Extend extends Functor
  extend : Extend 'm â‡’ 'm<'a> â†’ ('m<'a> â†’ 'b) â†’ 'm<'b>

type Filterable<'a>
trait Filterable
  filter : Filterable 'm â‡’ 'm<'a> â†’ ('a â†’ ğ”¹) â†’ 'm<'a>

type Foldable<'a>
trait Foldable
  reduce : Foldable 'm â‡’ 'm<'a> â†’ ('b â†’ 'a â†’ 'b) â†’ 'b â†’ 'b

type Functor<'a>
trait Functor
  map : Functor 'm â‡’ 'm<'a> â†’ ('a â†’ 'b) â†’ 'm<'b>

  # An infix alias for `map`.
  # @include map
  (<$>) â‰” map

type Group<'a> extends Monoid<'a>
trait Group extends Monoid
  invert : Group 'm â‡’ 'm<'a> â†’ 'm<'a>

type Monad<'a> extends Applicative<'a>, Chain<'a>
trait Monad extends Applicative Chain

type Monoid<'a> extends Semigroup<'a>
trait Monoid extends Semigroup
  # The empty value for a monoid.
  empty : Monoid 'm â‡’ 'm<'a>

  # @include empty
  âˆ… â‰” empty

type Ordered extends Setoid
trait Ordered extends Setoid
  # Less than or equal to. Returns true if the first argument is less than or
  # equal to the second argument.
  (â‰¤) : Ordered 'a â‡’ 'a â†’ 'a â†’ ğ”¹
  (<=) â‰” â‰¤

  # Strictly less than. Returns true if the first argument is strictly less than
  # the second argument.
  (<) : Ordered 'a â‡’ 'a â†’ 'a â†’ ğ”¹
  (<) â‰” a â†’ b â†’ Â¬ (a = b) âˆ§ (a â‰¤ b)

  # Greater than or equal to. Returns true if the first argument is greater than
  # or equal to the second argument.
  (â‰¥) : Ordered 'a â‡’ 'a â†’ 'a â†’ ğ”¹
  (â‰¥) â‰” a â†’ b â†’ (a = b) âˆ¨ (Â¬ (a â‰¤ b))
  (>=) â‰” â‰¥

  # Strict greater than. Returns true if the first argument is strictly greater
  # than the second argument.
  (>) : Ordered 'a â‡’ 'a â†’ 'a â†’ ğ”¹
  (>) â‰” Â¬ âˆ˜âˆ˜âˆ˜ â‰¤

type Plus<'a> extends Alt<'a>
trait Plus extends Alt
  zero : Plus 'm â‡’ 'm<_>

type Profunctor<'a, 'b> extends Functor<'b>
trait Profunctor extends Functor
  promap : Profunctor 'm â‡’ 'm<'b, 'c> â†’ ('a â†’ 'b) â†’ ('c â†’ 'd) â†’ 'm<'a, 'd>

type Semigroup<'a>
trait Semigroup
  # Combines two values by appending them together.
  concat : Semigroup 'm â‡’ 'm<'a> â†’ 'm<'a> â†’ 'm<'a>

  # An infix alias for `concat`.
  # @include concat
  (++) â‰” concat

type Semigroupoid<'a, 'b>
trait Semigroupoid
  # A composition function which takes two objects of the same type and returns
  # a new object which represents 'gluing' the two objects together.
  #
  # Objects implementing `Semigroupoid` should have a reasonable implementation
  # of `compose` which behaves nicely with respect to associativity. So, given
  # values `a`, `b`, and `c` of the same type:
  #
  # - `a âˆ˜ (b âˆ˜ c)` should be the same as `(a âˆ˜ b) âˆ˜ c`
  (âˆ˜) : Semigroupoid 'm â‡’ 'm<'a, 'b> â†’ 'm<'b, 'c> â†’ 'm<'a, 'c>

type Setoid
trait Setoid
  # An equality function for comparing two values of the same type. Equality
  # should behave nicely here, so that `=` is reflexive, symmetric, and
  # transitive. So, given values `a`, `b`, and `c` of the same type:
  #
  # - `a = a` should be true
  # - `a = b` should be the same as `b = a`
  # - if `a = b` and `b = c` are both true, then `a = c` should also be true
  # - if one of `a = b` or `b = c` are false, then `a = c` should also be false
  # - if both are false, `a = c` may be either true or false
  (=) : Setoid 'a â‡’ 'a â†’ 'a â†’ ğ”¹

type Traversable<'a> extends Foldable<'a>, Functor<'a>
trait Traversable extends Foldable Functor
  traverse : Traversable 't,  Applicative 'f
    â‡’ 't<'a> â†’ 'f<_> â†’ ('a â†’ 'f<'b>) â†’ 'f<'t<'b>>
