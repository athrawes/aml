type Alt<`a> extends Functor<`a>
	alt :: Alt `m => `m<`a> -> `m<`a> -> `m<`a>

type Alternative<`a> extends Applicative<`a>, Plus<`a>

type Applicative<`a> extends Apply<`a>
	new :: Applicative `m => `a -> `m<`a>

	(<$) :: Applicative `m => `m<`a> -> `b -> `m<`b>
	(<$) = ma -> b -> ma <$> (const b)

	($>) :: Applicative `m => `a -> `m<`b> -> `m<`a>
	($>) = ⇋ <$

	↑¹ :: Applicative `m => (`a -> `b) -> `m<`a> -> `m<`b>
	↑¹ = callback -> ma -> (new callback) <*> ma

	(<$>) = ⇋ ↑¹

	↑² :: Applicative `m => (`a -> `b -> `c) -> `m<`a> -> `m<`b> -> `m<`c>
	↑² = callback -> ma -> mb -> (new callback) <*> ma <*> mb

	↑³ :: Applicative `m
		=> (`a -> `b -> `c -> `d)
		-> `m<`a>
		-> `m<`b>
		-> `m<`c>
		-> `m<`d>
	↑³ = callback -> ma -> mb -> mc -> (new callback) <*> ma <*> mb <*> mc

type Apply<`a> extends Functor<`a>
	(<*>) :: Apply `m => `m<(`a -> `b)> -> `m<`a> -> `m<`b>

	(<**>) = ⇋ <*>

type Bifunctor<`a, `b> extends Functor<`b>
	bimap :: Bifunctor `m => `m<`a, `c> -> (`a -> `b) -> (`c -> `d) -> `m<`b, `d>

type Chainable<`a> extends Apply<`a>
	# Allows chaining functions which return instances of the current type.
	#
	# ```aml
	# Some 42
	# >>= (value -> value / 2) # Maybe<Float> (21.0)
	# >>= (value -> value / 5.0) # Maybe<Float> (4.2)
	# ```
	(>>=) :: Chainable `m => `m<`a> -> (`a -> `m<`b>) -> `m<`b>

	# An infix alias for `>>=`, but with the arguments reversed.
	#
	# @include >>=
	#
	# ```aml
	# (value -> value / 2)
	# =<< (Some 42) # Maybe<Float> (21)
	# ```
	(=<<) = ⇋ (>>=)

	# Composes two functions by Kleisli composition.
	(>=>) :: (`a -> `m<`b>) -> (`b -> `m<`c>) -> (`a -> `m<`c>)
	(>=>) = amb -> bmc -> amb ∘ ((⇋ >>=) bmc)

	# An infix alias for `>=>`, but with the arguments reversed.
	# @include >=>
	(<=<) = ⇋ (>=>)

type ChainRec<`a> extends Chainable<`a>
	chain_rec :: ChainRec `m => ((`a -> `c) -> (`b -> `c) -> `a -> `m<`c>) -> `a -> `m<`b>

type Contramap<`a>
	contramap :: Contravariant `m => `m<`a> -> (`b -> `a) -> `m<`b>

trait Comonad<`a> extends Extend<`a>
	extract :: Comonad `m => `m<`a> -> `a

type Extend<`a> extends Functor<`a>
	extend :: Extend `m => `m<`a> -> (`m<`a> -> `b) -> `m<`b>

type Filterable<`a>
	filter :: Filterable `m => `m<`a> -> (`a -> 𝔹) -> `m<`a>

type Foldable<`a>
	fold :: Foldable `m => `m<`a> -> (`a -> `a -> `a) -> `a
	reduce :: Foldable `m => `m<`a> -> (`b -> `a -> `b) -> `b -> `b

type Functor<`a>
	(<$>) :: Functor `m => `m<`a> -> (`a -> `b) -> `m<`b>

type Group<`a> extends Monoid<`a>
	invert :: Group `m => `m<`a> -> `m<`a>

type Monad<`a> extends Applicative<`a>, Chainable<`a>

type Monoid<`a> extends Appendable<`a>
	# The empty value for a monoid.
	∅ :: Monoid `m => `m<`a>
	empty = ∅

type Orderable<`a> extends Comparable<`a>
	# Less than or equal to. Returns true if the first argument is less than or
	# equal to the second argument.
	(≤) :: Orderable `a => `a -> `a -> 𝔹

	# Strictly less than. Returns true if the first argument is strictly less than
	# the second argument.
	(<) :: Orderable `a => `a -> `a -> 𝔹
	(<) = a -> b -> ¬ (a == b) ∧ (a ≤ b)

	# Greater than or equal to. Returns true if the first argument is greater than
	# or equal to the second argument.
	(≥) :: Orderable `a => `a -> `a -> 𝔹
	(≥) = a -> b -> (a == b) ∨ (¬ (a ≤ b))

	# Strict greater than. Returns true if the first argument is strictly greater
	# than the second argument.
	(>) :: Orderable `a => `a -> `a -> 𝔹
	(>) = ¬ ∘∘∘ ≤

type Plus<`a> extends Alt<`a>
	𝟘 :: Plus `m => `m<`a>
	(+) :: Plus `m => `m<`a> -> `m<`a> -> `m<`a>

type Profunctor<`a, `b> extends Functor<`b>
	promap :: Profunctor `m => `m<`b, `c> -> (`a -> `b) -> (`c -> `d) -> `m<`a, `d>

type Appendable<`a>
	# Combines two values by appending them together.
	(++) :: Appendable `m => `m<`a> -> `m<`a> -> `m<`a>

type Composable<`a, `b>
	# A composition function which takes two objects of the same type and returns
	# a new object which represents 'gluing' the two objects together.
	#
	# Objects implementing `Composable` should have a reasonable implementation
	# of `compose` which behaves nicely with respect to associativity. So, given
	# values `a`, `b`, and `c` of the same type:
	#
	# - `a ∘ (b ∘ c)` should be the same as `(a ∘ b) ∘ c`
	(∘) :: Composable `m => `m<`a, `b> -> `m<`b, `c> -> `m<`a, `c>
	(<∘) = ⇋ (∘)

type Comparable<`a>
	# An equality function for comparing two values of the same type. Equality
	# should behave nicely here, so that `==` is reflexive, symmetric, and
	# transitive. So, given values `a`, `b`, and `c` of the same type:
	#
	# - `a == a` should be true
	# - `a == b` should be the same as `b == a`
	# - if `a == b` and `b == c` are both true, then `a == c` should also be true
	# - if one of `a == b` or `b == c` are false, then `a == c` should also be false
	# - if both are false, `a == c` may be either true or false
	(==) :: Comparable `a => `a -> `a -> 𝔹

	# An inequality function for comparing two values of the same type. Simply
	# negates the result of the equality function.
	(!=) :: Comparable `a => `a -> `a -> 𝔹
	(!=) = ¬ ∘∘∘ ==

type Traversable<`a> extends Foldable<`a>, Functor<`a>
	traverse :: Traversable `t, Applicative `f
		=> `t<`a> -> `f<_> -> (`a -> `f<`b>) -> `f<`t<`b>>
