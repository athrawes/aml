let + :: infix ^T -> ^T -> ^T
  | where ^T is Integer
    := a -> b  -> INTRINSIC_INTEGER_ADDITION a b
  | where ^T is Float
    := a -> b -> INTRINSIC_FLOAT_ADDITION a b

let - :: infix ^T -> ^T -> ^T
  | where ^T is Integer
    := a -> b -> INTRINSIC_INTEGER_SUBTRACTION a b
  | where ^T is Float
    := a -> b -> INTRINSIC_FLOAT_SUBTRACTION a b

let * :: infix ^T -> ^T -> ^T
  | where ^T is Integer
    := a -> b -> INTRINSIC_INTEGER_MULTIPLICATION a b
  | where ^T is Float
    := a -> b -> INTRINSIC_FLOAT_MULTIPLICATION a b

let / :: infix ^T -> ^T -> Maybe[^T]
  | where ^T is Integer
    := a -> b -> match b
      | 0 -> None
      | _ -> Some(INTRINSIC_INTEGER_DIVISION a b)
  | where ^T is Float
    := a -> b -> match b
      | 0.0 -> None
      | _   -> Some(INTRINSIC_FLOAT_DIVISION a b)

let |> :: infix ^T -> (^T -> ^U) -> ^U
  := argument -> function -> function argument

let >> :: infix (^T -> ^U) -> (^U -> ^V) -> ^T -> ^V
  := function1
    -> function2
    -> argument
    -> argument |> function1 |> function2

let and :: infix ^T -> ^T -> ^T
  | where (^T is Number) or (^T is Boolean)
    := a -> b -> INTRINSIC_AND a b

let or :: infix ^T -> ^T -> ^T
  | where (^T is Number) or (^T is Boolean)
    := a -> b -> INTRINSIC_OR a b

let xor :: infix ^T -> ^T -> ^T
  | where (^T is Number) or (^T is Boolean)
    := a -> b -> INTRINSIC_XOR a b

let not :: Boolean -> Boolean
  := a -> INTRINSIC_NOT a

let <<< :: infix ^T -> Integer -> ^T
  | where (^T is Number)
    := a -> b -> INTRINSIC_BITWISE_LEFT_SHIFT a b

let >>> :: infix ^T -> Integer -> ^T
  | where (^T is Number)
    := a -> b -> INTRINSIC_BITWISE_RIGHT_SHIFT a b

let is :: infix ^T -> ^T -> Boolean
  | where ^T is Boolean
    := a -> b -> INTRINSIC_COMPARE a b
  | _ := _ -> _ -> false

let id :: ^T -> ^T
  := a -> a
