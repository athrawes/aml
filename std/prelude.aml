let + :: infix := add
let add :: ^T -> ^T -> ^T
  | where ^T is Integer
    := a -> b  -> INTRINSIC_INTEGER_ADDITION a b
  | where ^T is Float
    := a -> b -> INTRINSIC_FLOAT_ADDITION a b

let - :: infix := subtract
let subtract :: ^T -> ^T -> ^T
  | where ^T is Integer
    := a -> b -> INTRINSIC_INTEGER_SUBTRACTION a b
  | where ^T is Float
    := a -> b -> INTRINSIC_FLOAT_SUBTRACTION a b

let * :: infix := multiply
let multiply :: ^T -> ^T -> ^T
  | where ^T is Integer
    := a -> b -> INTRINSIC_INTEGER_MULTIPLICATION a b
  | where ^T is Float
    := a -> b -> INTRINSIC_FLOAT_MULTIPLICATION a b

let / :: infix := divide
let divide :: ^T -> ^T -> Maybe[^T]
  | where ^T is Integer
    := a -> b -> match b
      | 0  -> None
      | () -> Some(INTRINSIC_INTEGER_DIVISION a b)
  | where ^T is Float
    := a -> b -> match b
      | 0.0 -> None
      | ()  -> Some(INTRINSIC_FLOAT_DIVISION a b)

let |> :: infix := pipe
let pipe :: ^T -> (^T -> ^U) -> ^U
  := argument -> function -> function argument

let >> :: infix = compose
let compose :: (^T -> ^U) -> (^U -> ^V) -> ^T -> ^V
  := function1
    -> function2
    -> argument
    -> argument |> function1 |> function2

let swap-args :: (^T -> ^U -> ^V) -> ^U -> ^T -> V
  := fn -> a -> b -> fn b a

let and :: infix ^T -> ^T -> ^T
  | where (^T is Number) or (^T is Boolean)
    := a -> b -> INTRINSIC_AND a b

let or :: infix ^T -> ^T -> ^T
  | where (^T is Number) or (^T is Boolean)
    := a -> b -> INTRINSIC_OR a b

let xor :: infix ^T -> ^T -> ^T
  | where (^T is Number) or (^T is Boolean)
    := a -> b -> INTRINSIC_XOR a b

let not :: Boolean -> Boolean
  := a -> INTRINSIC_NOT a

let <<< :: infix := bitshift-left
let bitshift-left :: ^T -> Integer -> ^T
  | where (^T is Number)
    := a -> b -> INTRINSIC_BITWISE_LEFT_SHIFT a b

let >>> :: infix := bitshift-right
let bitshift-right :: ^T -> Integer -> ^T
  | where (^T is Number)
    := a -> b -> INTRINSIC_BITWISE_RIGHT_SHIFT a b

let is :: infix ^T -> ^T -> Boolean
  | where ^T is Boolean
    := a -> b -> INTRINSIC_COMPARE a b
  | _ := () -> () -> false

let id :: ^T -> ^T
  := a -> a

let if :: Boolean -> ^T -> ^T -> ^T
  := condition -> if-true -> if-false ->
    match condition
    | true => if-true
    | false => if-false

let while :: Boolean -> (() -> ^T) -> ()
  := condition -> expression ->
    match condition
    | false => _
    | true => (
        expression ()
        while condition expression
      )
